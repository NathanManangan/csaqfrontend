---
layout: default
title: Binary Search Lesson
search_exclude: false
toc: false
categories: []
---
<style>

a {
    color: #ffae00;
    text-decoration: none;
}

a:hover {
    color: #f6ff00;
    text-decoration: underline;
}

table {
    border: 1px solid #000;
    width: 100%;
}
td {
    border: 1px solid #000;
    background-color: #1d3b5d;
}
th {
    border: 1px solid #000;
    background-color: #ffae00;
    color: black
}

#editor, #editorB {
        margin: 0;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
		width: 750px; 
		height: 250px;
		font-size: 14px;
		border-top-left-radius: 10px;
        border-top-right-radius: 10px;
		resize: vertical;
		overflow-x: auto;
    }

    ::-webkit-scrollbar {
	width: 8px;
	}

	/* Track */
	::-webkit-scrollbar-track {
	background: #141414;
	}
	
	/* Handle */
	::-webkit-scrollbar-thumb {
	background: #4a4a4a; 
	border-radius: 4px;
	}

	/* Handle on hover */
	::-webkit-scrollbar-thumb:hover {
	background: #323232; 
	}

</style>

<div class="wrapper">

<h1> Topic 2 - Binary Search </h1>

<h2> Introduction </h2>

<p>Binary Search is a searching algorithm used in a sorted array by repeatedly dividing the search interval in half. 
    This topic can be tested on the AP Exam but it isnt commonly seen. </p>

<h2>Conditions</h2>

<p> 
- The data structure must be sorted. There are multiple ways to sort but the algorithm needs to be built for whichever search it is running.
</p>
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20220309171621/BinarySearch.png"><br/>


<h3>More In Depth</h3>



<div id="editor">class BinarySearch 
{
    // Returns index of x if it is present in arr[],
    // else return -1
    int binarySearch(int arr[], int x)
    {
        int l = 0, r = arr.length - 1;
        while (l <= r) {
            int m = l + (r - l) / 2;
 
            // Check if x is present at mid
            if (arr[m] == x)
                return m;
 
            // If x greater, ignore left half
            if (arr[m] < x)
                l = m + 1;
 
            // If x is smaller, ignore right half
            else
                r = m - 1;
        }
 
        // if we reach here, then element was
        // not present
        return -1;
    }
 
    // Driver method to test above
    public static void main(String args[])
    {
        BinarySearch ob = new BinarySearch();
        int arr[] = { 2, 3, 4, 10, 40 };
        int n = arr.length;
        int x = 10;
        int result = ob.binarySearch(arr, x);
        if (result == -1)
            System.out.println(
                "Element is not present in array");
        else
            System.out.println("Element is present at "
                               + "index " + result);
    }
}</div>


<h3>Hacks</h3>

<p>The merge sort part (Lab #1) of the lesson makes up 50% of the points (so it is out of 1.5 on our grading)</p>
<table>
    <tr><th>Hack</th><th>Points</th></tr>
    <tr><td>Merge Sort Hack #1</td><td>1.00</td></tr>
    <tr><td>In-Class Lesson Participation</td><td>0.35</td></tr>
    <tr><td>Extra Credit - Merge Sort Hack #2</td><td>0.15</td></tr>
</table>

<h4>Merge Sort Hack #1</h4>

<p>
- Use the integer mergesort that we created and adapt it to sort an array of Java String objects. We recommend using the compareTo() method of the String class for this.
</p>

<h4>Extra Credit Merge Sort Hack #2</h4>

<p>
- <b>Option 1:</b> Use the integer mergesort that we created and adapt it to use any other (non-primitive) object type. It should be clear how these objects are being sorted by the merge sort.
<br/>
- <b>Option 2:</b> Create your own merge sort hack. It should be clear how this is related to merge sort and how it is sorting the data.
</p>


</div>  